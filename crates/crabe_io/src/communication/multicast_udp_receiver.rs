use crate::constant::BUFFER_SIZE;
use log::error;
use std::io::Cursor;
use std::net::{IpAddr, Ipv4Addr, SocketAddr, SocketAddrV4, UdpSocket};
use std::io;
use socket2::{Domain, Protocol, SockAddr, Socket, Type};

/// A struct that handles a Multicast UDP Receiver.
pub struct MulticastUDPReceiver {
    /// The UDP socket that joins the multicast group.
    socket: UdpSocket,
    /// A buffer that is used to receive data from the socket without allocating
    /// new heap memory.
    buffer: [u8; BUFFER_SIZE],
}

#[cfg(unix)]
fn bind_multicast(socket: &Socket, addr: &SocketAddr) -> io::Result<()> {
    socket.bind(&socket2::SockAddr::from(*addr))
}

impl MulticastUDPReceiver {
    /// Creates a new `MulticastUDPReceiver` that joins an IPv4 multicast group.
    ///
    /// # Arguments
    ///
    /// * `ip`: The IP address of the multicast group as a string slice.
    /// * `port`: The port number of the multicast group.
    ///
    /// # Returns
    ///
    /// A new `MulticastUDPReceiver` that is ready to receive data in a
    /// non-blocking mode.
    ///
    /// # Errors
    ///
    /// This function will return an `Box<dyn std::error::Error>` if the IP
    /// address string cannot be parsed into an IPv4 address, if there is an
    /// error while binding the socket, joining the multicast group or setting
    /// the socket to non-blocking mode.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::net::Ipv4Addr;
    /// use crabe_io::communication::MulticastUDPReceiver;
    ///
    /// let receiver = MulticastUDPReceiver::new(Ipv4Addr::new(224,5,23,2), 10020).expect("Failed to create MulticastUDPReceiver");
    /// ```
    ///
    /// This example creates a new `MulticastUDPReceiver` that listens on IP
    /// address 224.5.23.2 and port 10020, which is the default grSim vision
    /// address and port.
    pub fn new(ip: Ipv4Addr, port: u16) -> Result<Self, Box<dyn std::error::Error>> {
        // let socket = UdpSocket::bind(SocketAddrV4::new(Ipv4Addr::UNSPECIFIED, port))?;
        //
        // socket.join_multicast_v4(&ip, &Ipv4Addr::UNSPECIFIED)?;
        // socket.set_nonblocking(true)?;
        
        if !ip.is_multicast() {
            return Err(Box::new(io::Error::new(
                io::ErrorKind::Other,
                format!("expected multicast address for binding: {}", ip),
            )));
        }
        
        let socket = Socket::new(
            Domain::IPV4,
            Type::DGRAM,
            Some(Protocol::UDP),
        ).expect("ipv4 dgram socket");
        socket.join_multicast_v4(&ip, &Ipv4Addr::new(0, 0, 0, 0)).expect("join_multicast_v4");
        
        // socket.set_nonblocking(true).expect("nonblocking Error");
        socket.set_reuse_address(true).expect("reuse addr Error");
        #[cfg(unix)] // this is currently restricted to Unix's in socket2
        {
            // socket.set_reuse_port(true).expect("reuse port Error");
        }
        let sa = SocketAddr::V4(SocketAddrV4::new(ip, port));
        bind_multicast(&socket, &sa).expect("bind Error");

        Ok(Self {
            socket: socket.into(),
            buffer: [0u8; BUFFER_SIZE],
        })
    }
    
    /// Attempts to receive a packet of type `T` from the socket and decode it
    /// using `prost`.
    ///
    /// # Returns
    ///
    /// An `Option` that contains the decoded packet if the receive operation is
    /// successful, or `None` otherwise.
    ///
    /// # Type Parameters
    ///
    /// * `T`: The type of the packet to decode. It must implement the
    ///   `prost::Message` and `Default` traits, and should be a struct
    ///   generated by protobuf files using `prost`.
    pub fn receive<T: prost::Message + Default>(&mut self) -> Option<T> {
        if let Ok(p_size) = self.socket.recv(&mut self.buffer) {
            return match T::decode(Cursor::new(&self.buffer[0..p_size])) {
                Ok(packet) => Some(packet),
                Err(e) => {
                    error!("Decoding of the received packet failed: {}", e);
                    None
                }
            };
        } else {
            None
        }
    }
}
