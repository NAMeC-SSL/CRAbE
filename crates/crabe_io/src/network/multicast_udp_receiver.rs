use crate::constants::BUFFER_SIZE;
use std::io::Cursor;
use std::net::{Ipv4Addr, UdpSocket};
use std::str::FromStr;

/// A struct that handles a Multicast UDP Receiver.
pub struct MulticastUDPReceiver {
    /// The UDP socket that joins the multicast group.
    socket: UdpSocket,
    /// A buffer that is used to receive data from the socket without allocating new heap memory.
    buffer: [u8; BUFFER_SIZE],
}

impl MulticastUDPReceiver {
    /// Creates a new `MulticastUDPReceiver` that joins an IPv4 multicast group.
    ///
    /// # Arguments
    ///
    /// * `ip`: The IP address of the Multicast UDP receiver as a string slice.
    /// * `port`: The port number of the Multicast UDP receiver.
    ///
    /// # Returns
    ///
    /// A new `MulticastUDPReceiver` that is ready to receive data.
    ///
    /// # Example
    ///
    /// ```
    /// use crabe_io::network::MulticastUDPReceiver;
    ///
    /// let receiver = MulticastUDPReceiver::new("224.5.23.2", 10020);
    /// ```
    ///
    /// This example creates a new `MulticastUDPReceiver` that listens on IP address 224.5.23.2 and port 10020, which is the default grSim vision address and port.
    pub fn new(ip: &str, port: u32) -> Self {
        let ipv4 = Ipv4Addr::from_str(ip).expect("TODO: Failed to parse vision server ip");
        let socket =
            UdpSocket::bind(format!("{}:{}", ip, port)).expect("Failed to bind the UDP Socket");
        socket
            .join_multicast_v4(&ipv4, &Ipv4Addr::UNSPECIFIED)
            .expect("Error to join multicast group");
        socket
            .set_nonblocking(true)
            .expect("Failed to set non blocking");

        Self {
            socket,
            buffer: [0u8; BUFFER_SIZE],
        }
    }

    /// Attempts to receive a packet of type `T` from the socket and decode it using `prost`.    
    ///
    /// # Returns
    ///
    /// An `Option` that contains the decoded packet if the receive operation is successful, or `None` otherwise.
    ///
    /// # Type Parameters
    ///
    /// * `T`: The type of the packet to decode. It must implement the `prost::Message` and `Default` traits, and should be a struct generated by protobuf files using `prost`.
    pub fn receive<T: prost::Message + Default>(&mut self) -> Option<T> {
        if let Ok(p_size) = self.socket.recv(&mut self.buffer) {
            let packet = T::decode(Cursor::new(&self.buffer[0..p_size]))
                .expect("Error - Decoding the packet");
            Some(packet)
        } else {
            None
        }
    }
}
